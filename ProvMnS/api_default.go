/*
Provisioning MnS

OAS 3.0.1 definition of the Provisioning MnS Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.

API version: 17.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi_ProvMnS

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type DefaultApi interface {

	/*
	ClassNameidDelete Deletes one or multiple resources

	With HTTP DELETE resources are deleted. The resources to be deleted are identified with the target URI.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param className
	@param id
	@return ApiClassNameidDeleteRequest
	*/
	ClassNameidDelete(ctx context.Context, className string, id string) ApiClassNameidDeleteRequest

	// ClassNameidDeleteExecute executes the request
	ClassNameidDeleteExecute(r ApiClassNameidDeleteRequest) (*http.Response, error)

	/*
	ClassNameidGet Reads one or multiple resources

	With HTTP GET resources are read. The resources to be retrieved are identified with the target URI. The attributes and fields parameter of the query components allow to select the resource properties to be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param className
	@param id
	@return ApiClassNameidGetRequest
	*/
	ClassNameidGet(ctx context.Context, className string, id string) ApiClassNameidGetRequest

	// ClassNameidGetExecute executes the request
	//  @return Resource
	ClassNameidGetExecute(r ApiClassNameidGetRequest) (*Resource, *http.Response, error)

	/*
	ClassNameidPatch Patches one or multiple resources

	With HTTP PATCH resources are created, updated or deleted. The resources to be modified are identified with the target URI (base resource) and the patch document included in the request message body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param className
	@param id
	@return ApiClassNameidPatchRequest
	*/
	ClassNameidPatch(ctx context.Context, className string, id string) ApiClassNameidPatchRequest

	// ClassNameidPatchExecute executes the request
	//  @return Resource
	ClassNameidPatchExecute(r ApiClassNameidPatchRequest) (*Resource, *http.Response, error)

	/*
	ClassNameidPut Replaces a complete single resource or creates it if it does not exist

	With HTTP PUT a complete resource is replaced or created if it does not exist. The target resource is identified by the target URI.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param className
	@param id
	@return ApiClassNameidPutRequest
	*/
	ClassNameidPut(ctx context.Context, className string, id string) ApiClassNameidPutRequest

	// ClassNameidPutExecute executes the request
	//  @return Resource
	ClassNameidPutExecute(r ApiClassNameidPutRequest) (*Resource, *http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiClassNameidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultApi
	className string
	id string
	scope *Scope
	filter *string
}

// This parameter extends the set of targeted resources beyond the base resource identified with the path component of the URI. No scoping mechanism is specified in the present document.
func (r ApiClassNameidDeleteRequest) Scope(scope Scope) ApiClassNameidDeleteRequest {
	r.scope = &scope
	return r
}

// This parameter reduces the targeted set of resources by applying a filter to the scoped set of resource representations. Only resources representations for which the filter construct evaluates to \&quot;true\&quot; are returned. No filter language is specified in the present document.
func (r ApiClassNameidDeleteRequest) Filter(filter string) ApiClassNameidDeleteRequest {
	r.filter = &filter
	return r
}

func (r ApiClassNameidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClassNameidDeleteExecute(r)
}

/*
ClassNameidDelete Deletes one or multiple resources

With HTTP DELETE resources are deleted. The resources to be deleted are identified with the target URI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className
 @param id
 @return ApiClassNameidDeleteRequest
*/
func (a *DefaultApiService) ClassNameidDelete(ctx context.Context, className string, id string) ApiClassNameidDeleteRequest {
	return ApiClassNameidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) ClassNameidDeleteExecute(r ApiClassNameidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ClassNameidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{className}={id}"
	localVarPath = strings.Replace(localVarPath, "{"+"className"+"}", url.PathEscape(parameterToString(r.className, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scope != nil {
		localVarQueryParams.Add("scope", parameterToString(*r.scope, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClassNameidGetRequest struct {
	ctx context.Context
	ApiService DefaultApi
	className string
	id string
	attributes *[]string
	scope *Scope
	filter *string
	fields *[]string
}

// This parameter specifies the attributes of the scoped resources that are returned.
func (r ApiClassNameidGetRequest) Attributes(attributes []string) ApiClassNameidGetRequest {
	r.attributes = &attributes
	return r
}

// This parameter extends the set of targeted resources beyond the base resource identified with the path component of the URI. No scoping mechanism is specified in the present document.
func (r ApiClassNameidGetRequest) Scope(scope Scope) ApiClassNameidGetRequest {
	r.scope = &scope
	return r
}

// This parameter reduces the targeted set of resources by applying a filter to the scoped set of resource representations. Only resource representations for which the filter construct evaluates to \&quot;true\&quot; are targeted. No filter language is specified in the present document.
func (r ApiClassNameidGetRequest) Filter(filter string) ApiClassNameidGetRequest {
	r.filter = &filter
	return r
}

// This parameter specifies the attribute field of the scoped resources that are returned.
func (r ApiClassNameidGetRequest) Fields(fields []string) ApiClassNameidGetRequest {
	r.fields = &fields
	return r
}

func (r ApiClassNameidGetRequest) Execute() (*Resource, *http.Response, error) {
	return r.ApiService.ClassNameidGetExecute(r)
}

/*
ClassNameidGet Reads one or multiple resources

With HTTP GET resources are read. The resources to be retrieved are identified with the target URI. The attributes and fields parameter of the query components allow to select the resource properties to be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className
 @param id
 @return ApiClassNameidGetRequest
*/
func (a *DefaultApiService) ClassNameidGet(ctx context.Context, className string, id string) ApiClassNameidGetRequest {
	return ApiClassNameidGetRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
		id: id,
	}
}

// Execute executes the request
//  @return Resource
func (a *DefaultApiService) ClassNameidGetExecute(r ApiClassNameidGetRequest) (*Resource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Resource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ClassNameidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{className}={id}"
	localVarPath = strings.Replace(localVarPath, "{"+"className"+"}", url.PathEscape(parameterToString(r.className, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attributes == nil {
		return localVarReturnValue, nil, reportError("attributes is required and must be specified")
	}

	if r.scope != nil {
		localVarQueryParams.Add("scope", parameterToString(*r.scope, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	localVarQueryParams.Add("attributes", parameterToString(*r.attributes, "csv"))
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClassNameidPatchRequest struct {
	ctx context.Context
	ApiService DefaultApi
	className string
	id string
	resource *Resource
}

// The request body describes changes to be made to the target resources. The following patch media types are available   - \&quot;application/merge-patch+json\&quot; (RFC 7396)   - \&quot;application/3gpp-merge-patch+json\&quot; (TS 32.158)   - \&quot;application/json-patch+json\&quot; (RFC 6902)   - \&quot;application/3gpp-json-patch+json\&quot; (TS 32.158)
func (r ApiClassNameidPatchRequest) Resource(resource Resource) ApiClassNameidPatchRequest {
	r.resource = &resource
	return r
}

func (r ApiClassNameidPatchRequest) Execute() (*Resource, *http.Response, error) {
	return r.ApiService.ClassNameidPatchExecute(r)
}

/*
ClassNameidPatch Patches one or multiple resources

With HTTP PATCH resources are created, updated or deleted. The resources to be modified are identified with the target URI (base resource) and the patch document included in the request message body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className
 @param id
 @return ApiClassNameidPatchRequest
*/
func (a *DefaultApiService) ClassNameidPatch(ctx context.Context, className string, id string) ApiClassNameidPatchRequest {
	return ApiClassNameidPatchRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
		id: id,
	}
}

// Execute executes the request
//  @return Resource
func (a *DefaultApiService) ClassNameidPatchExecute(r ApiClassNameidPatchRequest) (*Resource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Resource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ClassNameidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{className}={id}"
	localVarPath = strings.Replace(localVarPath, "{"+"className"+"}", url.PathEscape(parameterToString(r.className, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resource == nil {
		return localVarReturnValue, nil, reportError("resource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json", "application/3gpp-merge-patch+json", "application/json-patch+json", "application/3gpp-json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClassNameidPutRequest struct {
	ctx context.Context
	ApiService DefaultApi
	className string
	id string
	resource *Resource
}

func (r ApiClassNameidPutRequest) Resource(resource Resource) ApiClassNameidPutRequest {
	r.resource = &resource
	return r
}

func (r ApiClassNameidPutRequest) Execute() (*Resource, *http.Response, error) {
	return r.ApiService.ClassNameidPutExecute(r)
}

/*
ClassNameidPut Replaces a complete single resource or creates it if it does not exist

With HTTP PUT a complete resource is replaced or created if it does not exist. The target resource is identified by the target URI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className
 @param id
 @return ApiClassNameidPutRequest
*/
func (a *DefaultApiService) ClassNameidPut(ctx context.Context, className string, id string) ApiClassNameidPutRequest {
	return ApiClassNameidPutRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
		id: id,
	}
}

// Execute executes the request
//  @return Resource
func (a *DefaultApiService) ClassNameidPutExecute(r ApiClassNameidPutRequest) (*Resource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Resource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ClassNameidPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{className}={id}"
	localVarPath = strings.Replace(localVarPath, "{"+"className"+"}", url.PathEscape(parameterToString(r.className, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resource == nil {
		return localVarReturnValue, nil, reportError("resource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
