/*
Fault Supervision MnS

OAS 3.0.1 definition of the Fault Supervision MnS Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.

API version: 17.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi_FaultMnS

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type DefaultApi interface {

	/*
	AlarmsAlarmCountGet Get the alarm count per perceived severity

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlarmsAlarmCountGetRequest
	*/
	AlarmsAlarmCountGet(ctx context.Context) ApiAlarmsAlarmCountGetRequest

	// AlarmsAlarmCountGetExecute executes the request
	//  @return AlarmCount
	AlarmsAlarmCountGetExecute(r ApiAlarmsAlarmCountGetRequest) (*AlarmCount, *http.Response, error)

	/*
	AlarmsAlarmIdCommentsPost Add a comment to a single alarm

	Adds a comment to an alarm identified by alarmId. The id of the new comment is allocated by the producer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alarmId Identifies the alarm to which the comment shall be added.
	@return ApiAlarmsAlarmIdCommentsPostRequest
	*/
	AlarmsAlarmIdCommentsPost(ctx context.Context, alarmId string) ApiAlarmsAlarmIdCommentsPostRequest

	// AlarmsAlarmIdCommentsPostExecute executes the request
	//  @return Comment
	AlarmsAlarmIdCommentsPostExecute(r ApiAlarmsAlarmIdCommentsPostRequest) (*Comment, *http.Response, error)

	/*
	AlarmsAlarmIdPatch Clear, acknowledge or unacknowledge a single alarm

	Clears, acknowledges or uncknowldeges a single alarm by patching the alarm information. A conditional acknowledge request based on the perceived severity is not supported.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alarmId Identifies the alarm to be patched.
	@return ApiAlarmsAlarmIdPatchRequest
	*/
	AlarmsAlarmIdPatch(ctx context.Context, alarmId string) ApiAlarmsAlarmIdPatchRequest

	// AlarmsAlarmIdPatchExecute executes the request
	AlarmsAlarmIdPatchExecute(r ApiAlarmsAlarmIdPatchRequest) (*http.Response, error)

	/*
	AlarmsGet Retrieve multiple alarms

	Retrieves the alarms identified by alarmAckState, baseObjectInstance and filter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlarmsGetRequest
	*/
	AlarmsGet(ctx context.Context) ApiAlarmsGetRequest

	// AlarmsGetExecute executes the request
	//  @return map[string]AlarmsGet200ResponseValue
	AlarmsGetExecute(r ApiAlarmsGetRequest) (*map[string]AlarmsGet200ResponseValue, *http.Response, error)

	/*
	AlarmsPatch Clear, acknowledge or unacknowledge multiple alarms

	Clears, acknowledges or unacknowledges multiple alarms using patch. Depending on which action is to be performed, different merge patch documents need to be used.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlarmsPatchRequest
	*/
	AlarmsPatch(ctx context.Context) ApiAlarmsPatchRequest

	// AlarmsPatchExecute executes the request
	AlarmsPatchExecute(r ApiAlarmsPatchRequest) (*http.Response, error)

	/*
	SubscriptionsPost Create a subscription

	To create a subscription the representation of the subscription is POSTed on the /subscriptions collection resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSubscriptionsPostRequest
	*/
	SubscriptionsPost(ctx context.Context) ApiSubscriptionsPostRequest

	// SubscriptionsPostExecute executes the request
	//  @return Subscription
	SubscriptionsPostExecute(r ApiSubscriptionsPostRequest) (*Subscription, *http.Response, error)

	/*
	SubscriptionsSubscriptionIdDelete Delete a subscription

	The subscription is deleted by deleting the corresponding subscription resource. The resource to be deleted is identified with the path component of the URI.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subscriptionId Identifies the subscription to be deleted.
	@return ApiSubscriptionsSubscriptionIdDeleteRequest
	*/
	SubscriptionsSubscriptionIdDelete(ctx context.Context, subscriptionId string) ApiSubscriptionsSubscriptionIdDeleteRequest

	// SubscriptionsSubscriptionIdDeleteExecute executes the request
	SubscriptionsSubscriptionIdDeleteExecute(r ApiSubscriptionsSubscriptionIdDeleteRequest) (*http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAlarmsAlarmCountGetRequest struct {
	ctx context.Context
	ApiService DefaultApi
	alarmAckState *AlarmAckState
	filter *string
}

func (r ApiAlarmsAlarmCountGetRequest) AlarmAckState(alarmAckState AlarmAckState) ApiAlarmsAlarmCountGetRequest {
	r.alarmAckState = &alarmAckState
	return r
}

func (r ApiAlarmsAlarmCountGetRequest) Filter(filter string) ApiAlarmsAlarmCountGetRequest {
	r.filter = &filter
	return r
}

func (r ApiAlarmsAlarmCountGetRequest) Execute() (*AlarmCount, *http.Response, error) {
	return r.ApiService.AlarmsAlarmCountGetExecute(r)
}

/*
AlarmsAlarmCountGet Get the alarm count per perceived severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlarmsAlarmCountGetRequest
*/
func (a *DefaultApiService) AlarmsAlarmCountGet(ctx context.Context) ApiAlarmsAlarmCountGetRequest {
	return ApiAlarmsAlarmCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlarmCount
func (a *DefaultApiService) AlarmsAlarmCountGetExecute(r ApiAlarmsAlarmCountGetRequest) (*AlarmCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlarmCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlarmsAlarmCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/alarmCount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.alarmAckState != nil {
		localVarQueryParams.Add("alarmAckState", parameterToString(*r.alarmAckState, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlarmsAlarmIdCommentsPostRequest struct {
	ctx context.Context
	ApiService DefaultApi
	alarmId string
	comment *Comment
}

func (r ApiAlarmsAlarmIdCommentsPostRequest) Comment(comment Comment) ApiAlarmsAlarmIdCommentsPostRequest {
	r.comment = &comment
	return r
}

func (r ApiAlarmsAlarmIdCommentsPostRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.AlarmsAlarmIdCommentsPostExecute(r)
}

/*
AlarmsAlarmIdCommentsPost Add a comment to a single alarm

Adds a comment to an alarm identified by alarmId. The id of the new comment is allocated by the producer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alarmId Identifies the alarm to which the comment shall be added.
 @return ApiAlarmsAlarmIdCommentsPostRequest
*/
func (a *DefaultApiService) AlarmsAlarmIdCommentsPost(ctx context.Context, alarmId string) ApiAlarmsAlarmIdCommentsPostRequest {
	return ApiAlarmsAlarmIdCommentsPostRequest{
		ApiService: a,
		ctx: ctx,
		alarmId: alarmId,
	}
}

// Execute executes the request
//  @return Comment
func (a *DefaultApiService) AlarmsAlarmIdCommentsPostExecute(r ApiAlarmsAlarmIdCommentsPostRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlarmsAlarmIdCommentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/{alarmId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"alarmId"+"}", url.PathEscape(parameterToString(r.alarmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.comment == nil {
		return localVarReturnValue, nil, reportError("comment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.comment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlarmsAlarmIdPatchRequest struct {
	ctx context.Context
	ApiService DefaultApi
	alarmId string
	alarmsAlarmIdPatchRequest *AlarmsAlarmIdPatchRequest
}

func (r ApiAlarmsAlarmIdPatchRequest) AlarmsAlarmIdPatchRequest(alarmsAlarmIdPatchRequest AlarmsAlarmIdPatchRequest) ApiAlarmsAlarmIdPatchRequest {
	r.alarmsAlarmIdPatchRequest = &alarmsAlarmIdPatchRequest
	return r
}

func (r ApiAlarmsAlarmIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.AlarmsAlarmIdPatchExecute(r)
}

/*
AlarmsAlarmIdPatch Clear, acknowledge or unacknowledge a single alarm

Clears, acknowledges or uncknowldeges a single alarm by patching the alarm information. A conditional acknowledge request based on the perceived severity is not supported.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alarmId Identifies the alarm to be patched.
 @return ApiAlarmsAlarmIdPatchRequest
*/
func (a *DefaultApiService) AlarmsAlarmIdPatch(ctx context.Context, alarmId string) ApiAlarmsAlarmIdPatchRequest {
	return ApiAlarmsAlarmIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		alarmId: alarmId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AlarmsAlarmIdPatchExecute(r ApiAlarmsAlarmIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlarmsAlarmIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/{alarmId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alarmId"+"}", url.PathEscape(parameterToString(r.alarmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alarmsAlarmIdPatchRequest == nil {
		return nil, reportError("alarmsAlarmIdPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alarmsAlarmIdPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAlarmsGetRequest struct {
	ctx context.Context
	ApiService DefaultApi
	alarmAckState *AlarmAckState
	baseObjectInstance *string
	filter *string
}

func (r ApiAlarmsGetRequest) AlarmAckState(alarmAckState AlarmAckState) ApiAlarmsGetRequest {
	r.alarmAckState = &alarmAckState
	return r
}

func (r ApiAlarmsGetRequest) BaseObjectInstance(baseObjectInstance string) ApiAlarmsGetRequest {
	r.baseObjectInstance = &baseObjectInstance
	return r
}

func (r ApiAlarmsGetRequest) Filter(filter string) ApiAlarmsGetRequest {
	r.filter = &filter
	return r
}

func (r ApiAlarmsGetRequest) Execute() (*map[string]AlarmsGet200ResponseValue, *http.Response, error) {
	return r.ApiService.AlarmsGetExecute(r)
}

/*
AlarmsGet Retrieve multiple alarms

Retrieves the alarms identified by alarmAckState, baseObjectInstance and filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlarmsGetRequest
*/
func (a *DefaultApiService) AlarmsGet(ctx context.Context) ApiAlarmsGetRequest {
	return ApiAlarmsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]AlarmsGet200ResponseValue
func (a *DefaultApiService) AlarmsGetExecute(r ApiAlarmsGetRequest) (*map[string]AlarmsGet200ResponseValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]AlarmsGet200ResponseValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlarmsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.alarmAckState != nil {
		localVarQueryParams.Add("alarmAckState", parameterToString(*r.alarmAckState, ""))
	}
	if r.baseObjectInstance != nil {
		localVarQueryParams.Add("baseObjectInstance", parameterToString(*r.baseObjectInstance, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlarmsPatchRequest struct {
	ctx context.Context
	ApiService DefaultApi
	alarmsGetRequest *AlarmsGetRequest
}

// Patch documents for acknowledging and unacknowledging, or clearing multiple alarms. The keys in the map are the alarmIds to be patched.
func (r ApiAlarmsPatchRequest) AlarmsGetRequest(alarmsGetRequest AlarmsGetRequest) ApiAlarmsPatchRequest {
	r.alarmsGetRequest = &alarmsGetRequest
	return r
}

func (r ApiAlarmsPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.AlarmsPatchExecute(r)
}

/*
AlarmsPatch Clear, acknowledge or unacknowledge multiple alarms

Clears, acknowledges or unacknowledges multiple alarms using patch. Depending on which action is to be performed, different merge patch documents need to be used.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlarmsPatchRequest
*/
func (a *DefaultApiService) AlarmsPatch(ctx context.Context) ApiAlarmsPatchRequest {
	return ApiAlarmsPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) AlarmsPatchExecute(r ApiAlarmsPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AlarmsPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/merge-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alarmsGetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []FailedAlarm
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubscriptionsPostRequest struct {
	ctx context.Context
	ApiService DefaultApi
	subscription *Subscription
}

func (r ApiSubscriptionsPostRequest) Subscription(subscription Subscription) ApiSubscriptionsPostRequest {
	r.subscription = &subscription
	return r
}

func (r ApiSubscriptionsPostRequest) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.SubscriptionsPostExecute(r)
}

/*
SubscriptionsPost Create a subscription

To create a subscription the representation of the subscription is POSTed on the /subscriptions collection resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubscriptionsPostRequest
*/
func (a *DefaultApiService) SubscriptionsPost(ctx context.Context) ApiSubscriptionsPostRequest {
	return ApiSubscriptionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Subscription
func (a *DefaultApiService) SubscriptionsPostExecute(r ApiSubscriptionsPostRequest) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SubscriptionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscription == nil {
		return localVarReturnValue, nil, reportError("subscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsSubscriptionIdDeleteRequest struct {
	ctx context.Context
	ApiService DefaultApi
	subscriptionId string
}

func (r ApiSubscriptionsSubscriptionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsSubscriptionIdDeleteExecute(r)
}

/*
SubscriptionsSubscriptionIdDelete Delete a subscription

The subscription is deleted by deleting the corresponding subscription resource. The resource to be deleted is identified with the path component of the URI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionId Identifies the subscription to be deleted.
 @return ApiSubscriptionsSubscriptionIdDeleteRequest
*/
func (a *DefaultApiService) SubscriptionsSubscriptionIdDelete(ctx context.Context, subscriptionId string) ApiSubscriptionsSubscriptionIdDeleteRequest {
	return ApiSubscriptionsSubscriptionIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
func (a *DefaultApiService) SubscriptionsSubscriptionIdDeleteExecute(r ApiSubscriptionsSubscriptionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SubscriptionsSubscriptionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscriptions/{subscriptionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterToString(r.subscriptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
